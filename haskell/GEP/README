-- This module implements the GEP-RNC algorithm as detailed in the
-- book by CÃ¢ndida Ferreira, Gene Expression Programming. The main
-- focus is GEP-PO which is gene expression programming for parameter
-- optimisation.

-- In GEP-RNC There are 3 domains per gene: the head, the tail and the
-- Dc domain. 

-- The head domain represents the expression tree so it can contain
-- operator symbols (+-*/) as well as terminal symbols which may
-- represent variables, numerical constants or random number
-- constants. The length (h) of the head section (number of symbols)
-- is an independant parameter for the GEP algorithms.

-- The tail domain can only contain terminal characters. Its purpose
-- is to ensure every operator in the head domain is fully applied.
-- This requirement sets its length (t) as a function of the head
-- length.

-- The Dc domain is designed for handling the random number constants.
-- This section is seperate from the head/tail so is free to have its
-- own alphabet of any symbols. The symbols form the keys that map to
-- a set of randomly generated numbers (RNCs). The symbols are common
-- accross genes but the RNCs are not. That is each gene carries its
-- own set of RNCs. The number (n) of Dc-specific symbols is another
-- independant parameter for the GEP-RNC algorithm.

-- The random terminal '?' has a special meaning in the head domain.
-- Every '?' is replaced sequentially by an RNC starting with the RNC
-- identified by the first Dc-symbol and continuing down the Dc domain
-- until there are no more '?' characters in the head domain. This
-- means the Dc domain must have the same length (t) as the tail
-- domain for the same reason.

-- Each Gene is represented by (h+2t) symbols along with n RNCs.
-- In haskell lets use strict bytestrings for the symbols and unboxed
-- vectors for the RNCs

-- Multigenic systems are useful for optimization problems where each
-- gene represents a parameter of the problem. The collection of all
-- genes that represent a solution form a chromosome. For example if
-- the problem has two parameters than two genes per chromosome are
-- required. 

-- In terms of a haskell representation chromosomes can be
-- represented using the same gene-like structure the only difference
-- is that for multigenic systems the bytestring and vector will be
-- larger. Because the length of each gene is known the bytesting and
-- vector can be split into respective genes when needed. Indeed when
-- only one gene is present the terms gene and chromosome are

-- to generate a random gene we need to use the config (handled by
-- Reader monad) and pass around the random generator (handled by
-- StdRand monad). We can use the Reader monad transformer to stack
-- the monads.

-- generate random chromosome from config. Because genes are are
-- monoids to make a random chromosome we can just make multiple genes
-- and then concat them.
--
-- the fitness of individuals drives evolution. for now lets assume
-- fitness is a number between 0 and 1000. 0 represents an unviable
-- solution while 1000 represents a perfect solution. The fitenss
-- function is obviously problem specific and it is given in the
-- config.


-- so far we have dealt with: gene and chromosome representation,
-- configuration, creation random genes/chromosomes, gene/chromosome
-- execution and fitness calculation. What is left is the real nuts
-- and bolts of GEP the creation of new generations with selection and
-- modification operators. 
--
-- Throughout the GEP-Algorithm a record of the current population
-- must be kept at all times (we can used a boxed vector). Also the
-- next population is constructed from the last. This is an example of
-- a stateful computation where a state monad is useful. However we
-- will often want use the stateful population monad alongside other
-- monads like the Random monad. So we should also define a monad
-- transformer.


